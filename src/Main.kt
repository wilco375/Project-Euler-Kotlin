import java.lang.UnsupportedOperationException
import java.math.BigInteger
import java.util.*
import kotlin.collections.ArrayList
import kotlin.collections.HashMap
import kotlin.reflect.KFunction
import kotlin.reflect.jvm.javaMethod
import kotlin.reflect.jvm.kotlinFunction

/**
 * Main method
 */
fun main() {
    for (i in 1..999) {
        val start = System.currentTimeMillis()
        val function = getFunction("problem$i") ?: break
        println("Problem $i: ${function.call()} (took ${System.currentTimeMillis() - start} ms)")
    }
}

/**
 * Find a function in this file by its name
 * @param functionName name of the function to find
 * @return the function or null if not found
 */
fun getFunction(functionName: String): KFunction<*>? {
    return ::main.javaMethod!!.declaringClass.methods.find { it.name == functionName }?.kotlinFunction
}

/**
 * Problem 1
 *
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
 * Find the sum of all the multiples of 3 or 5 below 1000.
 */
fun problem1(): Int {
    val max = 1000
    var currentMultiplication = 1
    var sum = 0

    // Sum of multiples of 3 below 1000
    while (currentMultiplication * 3 < max) {
        sum += currentMultiplication * 3
        currentMultiplication++
    }

    // Sum of multiples of 5 below 1000
    currentMultiplication = 1
    while (currentMultiplication * 5 < max) {
        // Skip if the number is already added because it also divides 3
        if (currentMultiplication * 5 % 3 != 0) sum += currentMultiplication * 5
        currentMultiplication++
    }

    return sum
}

/**
 * Problem 2
 *
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */
fun problem2(): Int {
    val max = 4000000
    var sum = 0
    var n = 1
    var n2 = 2
    while (n2 <= max) {
        val temp = n
        n = n2
        n2 = temp + n

        if (n % 2 == 0) sum += n
    }

    return sum
}

/**
 * Problem 3
 *
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143 ?
 */
fun problem3(): Long {
    val number = 600851475143L
    var sqrt = Math.sqrt(number.toDouble()).toLong()

    // Make sure sqrt is uneven so loop only checks uneven numbers
    if (sqrt % 2 == 0L) sqrt++

    for (i in sqrt downTo 1 step 2) {
        if (number % i == 0L && i.isPrime()) return i
    }

    return 0
}

/**
 * Check if a number is prime
 * @return true if and only if the number is prime
 */
fun Long.isPrime(): Boolean {
    if (this == 1L) return false
    if (this == 2L) return true

    var testNumber = 2
    val sqrt = Math.sqrt(this.toDouble())
    while (testNumber <= sqrt) {
        if (this % testNumber == 0L) {
            return false
        }
        testNumber++
    }
    return true
}

/**
 * Problem 4
 *
 * A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
 * Find the largest palindrome made from the product of two 3-digit numbers.
 */
fun problem4(): Int {
    var largest = -1
    for (i in 999 downTo 100) {
        for (j in 999 downTo 100) {
            val multiplication = (i * j)
            if (multiplication > largest && multiplication.isPalindrome())
                largest = multiplication
        }
    }

    return largest
}

/**
 * Check if a number is a palindrome (reads the same both ways)
 * @return true if and only if the number is a palindrome
 */
fun Int.isPalindrome(): Boolean {
    return this.toString().isPalindrome()
}

/**
 * Check if a string is a palindrome (reads the same both ways)
 * @return true if and only if the string is a palindrome
 */
fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}

/**
 * Problem 5
 *
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
 * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
 */
fun problem5(): Int {
    var current = 20
    while (!current.divisibleTo(20)) {
        current++
    }
    return current
}

/**
 * Check if a number is divisible by the numbers 1 up to and including i
 * @param i maximum number that that the number should be divisible by
 * @return true if and only if the number is divisible by all the number 1 up to and including i
 */
fun Int.divisibleTo(i: Int): Boolean {
    // Don't need to check 1, it will divide any number
    return (2..i).firstOrNull { this % it != 0 } == null
}

/**
 * Problem 6
 *
 * The sum of the squares of the first ten natural numbers is,
 * 1^2 + 2^2 + ... + 10^2 = 385
 * The square of the sum of the first ten natural numbers is,
 * (1 + 2 + ... + 10)^2 = 552 = 3025
 * Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
 * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
 */
fun problem6(): Int {
    return (1..100).sum().square() - (1..100).square().sum()
}

/**
 * Square all the numbers in a sequence
 * @return a sequence of all the numbers in the original sequence squared
 */
fun Iterable<Int>.square(): Iterable<Int> {
    return this.map { it * it }
}

/**
 * Square a number
 * @return the square of the number
 */
fun Int.square(): Int {
    return this * this
}

/**
 * Square a number
 * @return the square of the number
 */
fun Long.square(): Long {
    return this * this
}

/**
 * Problem 7
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
 * What is the 10 001st prime number?
 */
fun problem7(): Long {
    var primesFound = 1
    var number: Long = 3
    while (true) {
        if (number.isPrime()) primesFound++
        if (primesFound == 10001) return number
        number++
    }
}

/**
 * Problem 8
 *
 * The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.=
 * Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
 */
fun problem8(): Long {
    val number = Data.problem8()
    val adjacentNumbers = 13

    val maxIndex = (0..number.length - adjacentNumbers).maxBy {
        number.substring(it until it + adjacentNumbers).split("").toIntList().product()
    } ?: return -1

    return number.substring(maxIndex until maxIndex + adjacentNumbers).split("").toIntList().product()
}

/**
 * Convert a sequence of strings to a sequence of the integers they represent
 * @return a sequence of integers
 */
fun Iterable<String>.toIntList(): List<Int> {
    return this.mapNotNull {
        it.toIntOrNull()
    }
}

/**
 * Convert a sequence of strings to a sequence of the long integers they represent
 * @return a sequence of longs
 */
fun Iterable<String>.toLongList(): List<Long> {
    return this.mapNotNull {
        it.toLongOrNull()
    }
}

/**
 * Calculate the product of the elements of an integer sequence
 * @return the product of all the integers in the sequence
 */
fun Iterable<Int>.product(): Long {
    var product: Long = 1
    for (element in this) {
        product *= element
    }
    return product
}

/**
 * Problem 9
 *
 * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
 * a2 + b2 = c2
 * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
 * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
 * Find the product abc.
 */
fun problem9(): Int {
    val sum = 1000
    for (c in 1..sum - 2) {
        for (b in 1 until c) {
            val a = (1 until b).firstOrNull { it.square() + b.square() == c.square() && it + b + c == 1000 }
            if (a != null) return a * b * c
        }
    }

    return -1
}

/*
 * Problem 10
 *
 * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
 * Find the sum of all the primes below two million.
 */
fun problem10(): Long {
    return (2 until 2000000L).filter { it.isPrime() }.sum()
}

/*
 * Problem 11
 *
 * In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
 * **Grid**
 * The product of these numbers is 26 × 63 × 78 × 14 = 1788696
 * What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
 */
fun problem11(): Long {
    val grid = Data.problem11()

    var largestUpDown = 0L
    for (i in 0..grid.size - 4) {
        val j = (0 until grid[i].size).maxBy { grid[i][it] * grid[i + 1][it] * grid[i + 2][it] * grid[i + 3][it] }
        if (j != null) {
            val product = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j]
            if (product > largestUpDown) largestUpDown = product
        }
    }

    var largestLeftRight = 0L
    for (i in 0 until grid.size) {
        val j = (0..grid[i].size - 4).maxBy { grid[i][it] * grid[i][it + 1] * grid[i][it + 2] * grid[i][it + 3] }
        if (j != null) {
            val product = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3]
            if (product > largestLeftRight) largestLeftRight = product
        }
    }

    var largestDiagonalLeftRight = 0L
    for (i in 0..grid.size - 4) {
        val j = (0..grid[i].size - 4).maxBy { grid[i][it] * grid[i + 1][it + 1] * grid[i + 2][it + 2] * grid[i + 3][it + 3] }
        if (j != null) {
            val product = grid[i][j] * grid[i][j + 1] * grid[i + 1][j + 2] * grid[i + 1][j + 3]
            if (product > largestDiagonalLeftRight) largestDiagonalLeftRight = product
        }
    }

    var largestDiagonalRightLeft = 0L
    for (i in 3 until grid.size) {
        val j = (0..grid[i].size - 4).maxBy { grid[i][it] * grid[i - 1][it + 1] * grid[i - 2][it + 2] * grid[i - 3][it + 3] }
        if (j != null) {
            val product = grid[i][j] * grid[i - 1][j + 1] * grid[i - 2][j + 2] * grid[i - 3][j + 3]
            if (product > largestDiagonalRightLeft) largestDiagonalRightLeft = product
        }
    }

    return longArrayOf(largestUpDown, largestLeftRight, largestDiagonalLeftRight, largestDiagonalRightLeft).max() ?: -1
}

/**
 * Problem 12
 *
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number
 * would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * Let us list the factors of the first seven triangle numbers:
 * **First seven triangle numbers**
 * We can see that 28 is the first triangle number to have over five divisors.
 * What is the value of the first triangle number to have over five hundred divisors?
 */
fun problem12(): Long {
    var number = 1L
    var triangle = 1L
    val divisors = 500

    while (triangle.countDivisors() <= divisors) triangle += ++number

    return triangle
}

/**
 * Calculate the number of different divisors a number has
 * @return number of divisors
 */
fun Long.countDivisors(): Int {
    var divisors = 0
    for (i in 1..Math.sqrt(this.toDouble()).toLong()) {
        if (i.square() == this)
            divisors += 1
        else if (this % i == 0L)
            divisors += 2
    }
    return divisors
}

/**
 * Problem 13
 *
 * Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
 * **50-digit numbers**
 */
fun problem13(): String {
    val numbers = Data.problem13()
    var sum = BigInteger.ZERO
    numbers.forEach { sum += it }
    return sum.toString().substring(0 until 10)
}

/**
 * Problem 14
 *
 * The following iterative sequence is defined for the set of positive integers:
 * n → n/2 (n is even)
 * n → 3n + 1 (n is odd)
 * Using the rule above and starting with 13, we generate the following sequence:
 * 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
 * It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem),
 * it is thought that all starting numbers finish at 1.
 * Which starting number, under one million, produces the longest chain?
 * NOTE: Once the chain starts the terms are allowed to go above one million.
 */
fun problem14(): Long {
    var largestChainLength = 0
    var largestChain = 0L
    for (i in 1 until 1000000L) {
        var chainLength = 0
        var number = i
        while (number != 1L) {
            if (number % 2 == 0L) {
                number /= 2
            } else {
                number = 3 * number + 1
            }
            chainLength++
        }
        if (chainLength > largestChainLength) {
            largestChainLength = chainLength
            largestChain = i
        }
    }
    return largestChain
}

/**
 * Problem 15
 *
 * Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down,
 * there are exactly 6 routes to the bottom right corner.
 * How many such routes are there through a 20×20 grid?
 */
fun problem15(): BigInteger {
    return 40 nCr 20
}

/**
 * Calculate n choose r
 * @param r r
 * @return this choose r
 */
infix fun Int.nCr(r: Int): BigInteger {
    return this.factorial() / (r.factorial() * (this - r).factorial())
}

/**
 * Calculate the factorial of a number
 * @return factorial
 */
fun Int.factorial(): BigInteger {
    return (1..this).bigProduct()
}

/**
 * Calculate the product of a sequence of integers as a big integer
 * @return product of integers in sequence
 */
fun Iterable<Int>.bigProduct(): BigInteger {
    var product = BigInteger.ONE
    for (element in this) {
        product *= BigInteger(element.toString())
    }
    return product
}

/**
 * Problem 16
 *
 * 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
 * What is the sum of the digits of the number 2^1000?
 */
fun problem16(): Int {
    return BigInteger("2").pow(1000).toString().split("").toIntList().sum()
}

/**
 * Problem 17
 *
 * If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
 * If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
 * NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen)
 * contains 20 letters.
 * The use of "and" when writing out numbers is in compliance with British usage.
 */
fun problem17(): Int {
    var length = 0
    (1..1000).forEach { length += it.toText().replace(" ", "").length }
    return length
}

/**
 * Convert an integer to its fully written out text version
 * @return written out version of the integer
 */
fun Int.toText(): String {
    val tensNames = arrayOf("", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety")
    val numNames = arrayOf("", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen")

    // 1-19
    if (numNames.size > this) {
        return numNames[this]
    }

    // 20-99
    if (this < 100) {
        return tensNames[this / 10] + numNames[this - this / 10 * 10]
    }

    // 100-999
    if (this < 1000) {
        // 100, 200, ..., 900
        if (this / 100 * 100 == this) return "${numNames[this / 100]} hundred"

        return "${numNames[this / 100]} hundred and ${(this - this / 100 * 100).toText()}"
    }

    // 1000
    if (this == 1000) {
        return "one thousand"
    }

    throw UnsupportedOperationException("Converting numbers larger than 1000 is not supported")
}

/**
 * Problem 18
 *
 * By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
 *    3
 *   7 4
 *  2 4 6
 * 8 5 9 3
 * That is, 3 + 7 + 4 + 9 = 23.
 * Find the maximum total from top to bottom of the triangle below:
 * **Pyramid**
 * NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67,
 * is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)
 */
fun problem18(): Int {
    val pyramid = Data.problem18()

    for (row in pyramid.size - 2 downTo 0) {
        for (item in 0 until pyramid[row].size) {
            pyramid[row][item] += Math.max(pyramid[row + 1][item], pyramid[row + 1][item + 1])
        }
    }

    return pyramid[0][0]
}

/**
 * Problem 19
 *
 * How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
 */
fun problem19(): Int {
    val calendar = Calendar.getInstance()
    calendar.set(1901, 0, 1)

    var sundays = 0
    while (calendar.get(Calendar.YEAR) <= 2000) {
        if (calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY && calendar.get(Calendar.DAY_OF_MONTH) == 1) {
            sundays++
        }
        calendar.add(Calendar.DAY_OF_MONTH, 1)
    }

    return sundays
}

/**
 * Problem 20
 *
 * n! means n × (n − 1) × ... × 3 × 2 × 1
 * For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
 * and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
 * Find the sum of the digits in the number 100!
 */
fun problem20(): Int {
    return 100.factorial().toString().split("").toIntList().sum()
}

/**
 * Problem 21
 *
 * Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
 * If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
 * For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284.
 * The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
 * Evaluate the sum of all the amicable numbers under 10000.
 */
fun problem21(): Int {
    val numbers = (1 until 10000).toMutableList()
    var sum = 0
    while (numbers.size > 0) {
        val number = numbers[0]
        val amicablePair = number.amicablePair()
        if (amicablePair != null) {
            sum += number + amicablePair
            numbers.remove(amicablePair)
        }
        numbers.remove(number)
    }

    return sum
}

/**
 * Calculate a number's amicable pair
 * @return the number's amicable pair (the sum of it's divisors) if it has one or null otherwise
 */
fun Int.amicablePair(): Int? {
    val sumOfDivisors = this.divisors().sum()
    if (sumOfDivisors != this) {
        val other = sumOfDivisors.divisors().sum()
        if (other == this) {
            return sumOfDivisors
        }
    }
    return null
}

/**
 * Calculate an integer's divisors
 * @return a list of divisors
 */
fun Int.divisors(): List<Int> {
    return (1..this / 2).filter { this % it == 0 }
}

/**
 * Problem 22
 *
 * Using names.txt (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names,
 * begin by sorting it into alphabetical order.
 * Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
 * For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list.
 * So, COLIN would obtain a score of 938 × 53 = 49714.
 * What is the total of all the name scores in the file?
 */
fun problem22(): Long {
    var score = 0L
    val names = Data.problem22()
    names.sort()
    val letterOffset = 'A'.toInt() - 1

    for (i in 0 until names.size) {
        val name = names[i].split("")
        var wordScore = 0
        name.forEach {
            if (!it.isEmpty()) {
                wordScore += it.toChar().toInt() - letterOffset
            }
        }
        score += wordScore * (i + 1)
    }

    return score
}

/**
 * Convert a char sequence to a single character
 * More logically named alias for CharSequence.single()
 * @return the first character of the char sequence
 */
fun CharSequence.toChar(): Char {
    return this.single()
}

/**
 * Problem 23
 *
 * A perfect number is a number for which the sum of its proper divisors is exactly equal to the number.
 * For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
 * A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
 * As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24.
 * By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
 * However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be
 * expressed as the sum of two abundant numbers is less than this limit.
 * Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
 */
fun problem23(): Int {
    val abundantNumbers = (1..28123).filter { it.divisors().sum() > it }
    val isSumsOfAbundantNumber = BooleanArray(28124, { false })
    for (number in abundantNumbers) {
        abundantNumbers.forEach { if (number + it <= 28123) isSumsOfAbundantNumber[number + it] = true }
    }
    return (1..28123).filter { !isSumsOfAbundantNumber[it] }.sum()
}

/**
 * Problem 24
 *
 * A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4.
 * If all of the permutations are listed numerically or alphabetically, we call it lexicographic order.
 * The lexicographic permutations of 0, 1 and 2 are:
 * 012   021   102   120   201   210
 * What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
 */
fun problem24(): String {
    val permutations = permutationsOf(0..9)
    permutations.sort()
    return permutations[1000000 - 1]
}

/**
 * Calculate all the possible permutations of the numbers in the range
 * @param range range of numbers to calculate permutations of
 */
fun permutationsOf(range: IntRange): ArrayList<String> {
    fun internalPermutationsOf(range: IntRange, vararg others: Int): ArrayList<String> {
        if (others.size == range.count()) {
            return arrayListOf(others.joinToString(""))
        } else {
            val list = ArrayList<String>()
            for (n in range excluding others.toList()) {
                list.addAll(internalPermutationsOf(range, *others, n))
            }
            return list
        }
    }

    return internalPermutationsOf(range)
}

/**
 * Remove the items of one integer sequence from another
 * @param excluding sequence excluding the integers in the other sequence
 */
infix fun Iterable<Int>.excluding(excluding: Iterable<Int>): Iterable<Int> {
    return this.filterNot { excluding.contains(it) }
}

/**
 * Problem 25
 *
 * The Fibonacci sequence is defined by the recurrence relation:
 * Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.
 * Hence the first 12 terms will be:
 * **Fibonacci sequence**
 * The 12th term, F12, is the first term to contain three digits.
 * What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
 */
fun problem25(): Int {
    return getFibonacciSequence().indexOfFirst { it.toString().length >= 1000 }
}

/**
 * Generator that generates the fibonacci sequence
 * @return fibonacci sequence as big integers
 */
fun getFibonacciSequence(): Sequence<BigInteger> {
    return sequence {
        yield(BigInteger.ZERO)
        var current = BigInteger.ONE
        var next = BigInteger.ONE
        while (true) {
            yield(current)
            val sum = current + next
            current = next
            next = sum
        }
    }
}

/**
 * Problem 26
 *
 * A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
 * **Fractions**
 * Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
 * Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
 */
fun problem26(): Int {
    var longestRecurringNumber = 0
    var longestRecurringLength = 0
    for (i in 1 until 1000) {
        val recurringLength = i.recurringCycleLength()
        if (recurringLength > longestRecurringLength) {
            longestRecurringLength = recurringLength
            longestRecurringNumber = i
        }
    }
    return longestRecurringNumber
}

/**
 * Get the length of the recurring decimal cycle of 1/number
 * For example 1/7 = 0.[142857] so the recurring cycle length is 6
 * @return recurring cycle length
 */
fun Int.recurringCycleLength(): Int {
    if (this.isNonRecurring()) return 0

    var lpow = 1
    while (true) {
        for (mpow in lpow - 1 downTo 0) {
            if ((10.pow(lpow) - 10.pow(mpow)) % BigInteger.valueOf(this.toLong()) == BigInteger.ZERO) {
                return lpow - mpow
            }
        }
        lpow += 1
    }
}

/**
 * Check if a number does not have any recurring decimals if we calculate 1/number
 * @return true if and only if the number does not have a recurring decimal sequence
 */
fun Int.isNonRecurring(): Boolean {
    if (this == 1 || this.isDivisibleDownTo(2) || this.isDivisibleDownTo(5)) return true
    return false
}

/**
 * Calculate the one integer to the power of another as a big integer
 * @param num number to raise to the power of
 * @return number to the power of num
 */
fun Int.pow(num: Int): BigInteger {
    return BigInteger.valueOf(this.toLong()).pow(num)
}

/**
 * Check if we end up at the number end if we keep dividing a number by 2
 * @param end number to end up at after repeatedly dividing by 2
 */
fun Int.isDivisibleDownTo(end: Int): Boolean {
    if (this == end) return true

    var result = this
    while (true) {
        if (result % 2 != 0) {
            return false
        } else if (result / 2 == end) {
            return true
        }
        result /= 2
    }
}

/**
 * Problem 27
 *
 * Euler discovered the remarkable quadratic formula:
 * n^2 + n + 41
 * It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤390≤n≤39.
 * However, when n=40, 40^2 + 40 + 41 = 40(40+1) + 41 is divisible by 41, and certainly when n=41,41^2+41+41 is clearly divisible by 41.
 * The incredible formula n^2 − 79n + 1601 was discovered, which produces 80 primes for the consecutive values 0 ≤ n ≤ 79.
 * The product of the coefficients, −79 and 1601, is −126479.
 * Considering quadratics of the form:
 * n^2+an+bn2+an+b, where |a| < 1000 and |b| ≤ 1000
 * where |n| is the modulus/absolute value of n e.g. |11| = 11 and |−4| = 4
 * Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes
 * for consecutive values of n, starting with n=0.
 */
fun problem27(): Int {
    var maximumPrimes = 0L
    var maximumPrimesA = 0
    var maximumPrimesB = 0
    for (a in -999..999) {
        for (b in -1000..1000) {
            var number = 0L
            while (Math.abs(number.square() + a * number + b).isPrime()) {
                number++
            }

            if (number > maximumPrimes) {
                maximumPrimes = number
                maximumPrimesA = a
                maximumPrimesB = b
            }
        }
    }
    return maximumPrimesA * maximumPrimesB
}

/**
 * Problem 28
 *
 * Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
 * **Spiral**
 * It can be verified that the sum of the numbers on the diagonals is 101.
 * What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
 */
fun problem28(): Int {
    val size = 1001
    val spiral = Array(size + 1) { Array(size + 1) { 0 } }
    spiral[size / 2 + 1][size / 2 + 1] = 1
    spiral[size / 2 + 1][size / 2 + 2] = 2
    spiral[size / 2 + 2][size / 2 + 2] = 3
    var direction = Direction.LEFT
    var (x, y) = Pair(size / 2 + 2, size / 2 + 2)
    var number = 3
    while (number <= size * size) {
        if (direction == Direction.LEFT) {
            while (spiral[y - 1][x] != 0) {
                spiral[y][x--] = number++
            }
            if (number >= size.square()) break
            spiral[y--][x] = number++
            direction = Direction.UP
        } else if (direction == Direction.UP) {
            while (spiral[y][x + 1] != 0) {
                spiral[y--][x] = number++
            }
            if (number >= size.square()) break
            spiral[y][x++] = number++
            direction = Direction.RIGHT
        } else if (direction == Direction.RIGHT) {
            while (spiral[y + 1][x] != 0) {
                spiral[y][x++] = number++
                if (x > size) break
            }
            if (number >= size.square()) break
            spiral[y++][x] = number++
            direction = Direction.DOWN
        } else if (direction == Direction.DOWN) {
            while (spiral[y][x - 1] != 0) {
                spiral[y++][x] = number++
                if (y > size) break
            }
            if (number >= size.square()) break
            spiral[y][x--] = number++
            direction = Direction.LEFT
        }
    }
    var sum = 0
    (1..size).forEach {
        sum += spiral[it][it] + spiral[size - it + 1][it]
    }
    sum -= spiral[size / 2 + 1][size / 2 + 1]

    return sum
}

enum class Direction {
    UP, RIGHT, DOWN, LEFT
}

/**
 * Problem 29
 *
 * Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
 * 2^2=4,  2^3=8,   2^4=16,  2^5=32
 * 3^2=9,  3^3=27,  3^4=81,  3^5=243
 * 4^2=16, 4^3=64,  4^4=256, 4^5=1024
 * 5^2=25, 5^3=125, 5^4=625, 5^5=3125
 * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 */
fun problem29(): Int {
    val terms = ArrayList<BigInteger>()
    val termsContains = HashMap<BigInteger, Boolean>()
    for (a in 2..100) {
        (2..100).forEach {
            val result = a.pow(it)
            if (!termsContains.containsKey(result)) {
                terms.add(result)
                termsContains[result] = true
            }
        }
    }
    return terms.size
}

/**
 * Problem 30
 *
 * Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
 * 1634 = 1^4 + 6^4 + 3^4 + 4^4
 * 8208 = 8^4 + 2^4 + 0^4 + 8^4
 * 9474 = 9^4 + 4^4 + 7^4 + 4^4
 * As 1 = 1^4 is not a sum it is not included.
 * The sum of these numbers is 1634 + 8208 + 9474 = 19316.
 * Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
 */
fun problem30(): Int {
    return (2..354294).filter { it.sumOfDigitsToPower(5) == it }.sum()
}

/**
 * Raise all the digits of an integer to a power and then sum those values
 * @param power power to raise to
 * @return sum
 */
fun Int.sumOfDigitsToPower(power: Int): Int {
    return this.toString().map { it.intVal().pow(power) }.sumBy { it.toInt() }
}

/**
 * Convert a char to an integer value that the char represents
 * @return integer value of char
 */
fun Char.intVal(): Int {
    val oneOffset = '1'.toInt() - 1
    return this.toInt() - oneOffset
}

/**
 * Problem 31
 *
 * In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation:
 * 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
 * It is possible to make £2 in the following way:
 * 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p
 * How many different ways can £2 be made using any number of coins?
 */
fun problem31(): Int {
    var options = 1
    for (hundred in 0..2) {
        for (fifty in 0..(200 - hundred * 100) / 50) {
            for (twenty in 0..(200 - hundred * 100 - fifty * 50) / 20) {
                for (ten in 0..(200 - hundred * 100 - fifty * 50 - twenty * 20) / 10) {
                    for (five in 0..(200 - hundred * 100 - fifty * 50 - twenty * 20 - ten * 10) / 5) {
                        for (two in 0..(200 - hundred * 100 - fifty * 50 - twenty * 20 - ten * 10 - five * 5) / 2) {
                            for (one in 0..(200 - hundred * 100 - fifty * 50 - twenty * 20 - ten * 10 - five * 5 - two * 2)) {
                                if (one * 1 + two * 2 + five * 5 + ten * 10 + twenty * 20 + fifty * 50 + hundred * 100 == 200) options++
                            }
                        }
                    }
                }
            }
        }
    }
    return options
}

/**
 * Problem 32
 *
 * We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example,
 * the 5-digit number, 15234, is 1 through 5 pandigital.
 * The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
 * Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
 * HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
 */
fun problem32(): Int {
    return (1..10000).filter { it.hasPandigitalProduct() }.sum()
}

/**
 * Check if an integer has a pandigital product
 * @return true if and only if the integer has a pandigital product
 */
fun Int.hasPandigitalProduct(): Boolean {
    (1..Math.sqrt(this.toDouble()).toInt()).firstOrNull { this % it == 0 && "$it${this / it}$this".isPandigital() } ?: return false
    return true
}

/**
 * Check if a string is pandigital, i.e. contains the digits 1..n where n is the string's length
 * @return true if and only if the string is pandigital
 */
fun String.isPandigital(): Boolean {
    return this.toSortedSet().joinToString(separator = "") == (1..this.length).joinToString("")
}

/**
 * Problem 33
 *
 * The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe
 * that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.
 * We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
 * There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the
 * numerator and denominator.
 * If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
 */
fun problem33(): Int {
    val fractions = ArrayList<Fraction>()
    for (numerator in 10..98) {
        for (denominator in numerator + 1..99) {
            val fraction = Fraction(numerator, denominator)
            if (fraction.digitCancelling() == Fraction.Cancelling.NONTRIVIAL) fractions.add(fraction)
        }
    }

    var product = Fraction(1, 1)
    fractions.forEach { product *= it }

    return product.denominator
}

/**
 * Calculate the greatest common devisor of a and b
 * @return greatest common devisor
 */
fun gcd(a: Int, b: Int): Int {
    var m = Math.abs(a)
    var n = Math.abs(b)
    while (n != 0) {
        val remainder = m % n
        m = n
        n = remainder
    }
    return m
}

data class Fraction(var numerator: Int, var denominator: Int) {
    enum class Cancelling {
        NONE, TRIVIAL, NONTRIVIAL, NOTSUPPORTED
    }

    /**
     * Simplify the fraction
     */
    fun simplify(): Fraction {
        val gcd = gcd(numerator, denominator)
        numerator /= gcd
        denominator /= gcd

        return this
    }

    /**
     * Convert the string to a double
     */
    fun toDouble(): Double {
        return numerator / denominator.toDouble()
    }

    /**
     * Convert the fraction to a string representation
     */
    override fun toString(): String {
        return "$numerator/$denominator"
    }

    /**
     * Multiply one fraction with another
     * @return product of the fractions
     */
    operator fun times(other: Fraction): Fraction {
        numerator *= other.numerator
        denominator *= other.denominator
        return simplify()
    }

    /**
     * Check if two fractions have the same value
     * @return true if and only if the two fractions have the same numerical value
     */
    override fun equals(other: Any?): Boolean {
        if (other is Fraction) return this.toDouble() == other.toDouble()

        return super.equals(other)
    }

    /**
     * Check what kind of digit cancelling the fraction has
     * Only supports fractions with a numerator and denominator of 2 digits
     * @return type of cancelling
     */
    fun digitCancelling(): Cancelling {
        val num = numerator.toString()
        val den = denominator.toString()

        if (num.length != 2 || den.length != 2) return Cancelling.NOTSUPPORTED

        if (num.substring(1, 2) == "0" && den.substring(1, 2) == "0") return Cancelling.TRIVIAL

        if (
                num.substring(0, 1) == den.substring(1, 2) && this == Fraction(num.substring(1, 2).toInt(), den.substring(0, 1).toInt()) ||
                num.substring(1, 2) == den.substring(0, 1) && this == Fraction(num.substring(0, 1).toInt(), den.substring(1, 2).toInt()) ||
                num.substring(0, 1) == den.substring(0, 1) && this == Fraction(num.substring(1, 2).toInt(), den.substring(1, 2).toInt())
        ) return Cancelling.NONTRIVIAL

        return Cancelling.NONE
    }
}

/**
 * Problem 34
 *
 * 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
 * Find the sum of all numbers which are equal to the sum of the factorial of their digits.
 * Note: as 1! = 1 and 2! = 2 are not sums they are not included.
 */
fun problem34(): Long {
    val upperBound = 9.factorial().toLong() * 8
    return (3..upperBound).filter { it.sumOfDigitsFactorial() == it }.sum()
}

/**
 * Calculate the factorial of all the digits in the number and then sum those values
 * @return sum of factorials of digits
 */
fun Long.sumOfDigitsFactorial(): Long {
    var sum = 0L
    for (digit in this.toString()) {
        sum += digit.intVal().factorialAsLong()
    }
    return sum
}

/**
 * Calculate the factorial of an integer as a long value
 * @return factorial of number
 */
fun Int.factorialAsLong(): Long {
    return (1..this).product()
}

/**
 * Problem 35
 *
 * The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
 * There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
 * How many circular primes are there below one million?
 */
fun problem35(): Int {
    return (1..1000000L).filter { it.isCircularPrime() }.size
}

/**
 * Check if a number is a circular prime
 * @return true if and only if the number is a circular prime
 */
fun Long.isCircularPrime(): Boolean {
    if (!this.isPrime()) return false
    if (this < 10 && this.isPrime()) return true

    var rotatedNumber = this.rotate()
    while (rotatedNumber != this) {
        if (!rotatedNumber.isPrime()) return false
        rotatedNumber = rotatedNumber.rotate()
    }
    return true
}

/**
 * Rotate a number, i.e. 197 will become 719
 *
 */
fun Long.rotate(): Long {
    val minusLastDigit = this / 10
    val lastDigit = this - minusLastDigit * 10
    return "$lastDigit$minusLastDigit".toLong()
}

/**
 * Problem 36
 *
 * The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.
 * Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
 * (Please note that the palindromic number, in either base, may not include leading zeros.)
 */
fun problem36(): Int {
    return (1 until 1000000).filter { it.isPalindrome() && it.toBinaryString().isPalindrome() }.sum()
}

/**
 * Convert an integer to binary
 * @return binary string representation of the integer
 */
fun Int.toBinaryString(): String {
    return Integer.toBinaryString(this)
}

/**
 * Problem 37
 *
 * The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right,
 * and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
 * Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
 * NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
 */
fun problem37(): Long {
    return getPrimes()
            .filter { it >= 10 }
            .filter { it.isTruncatablePrime() }
            .take(11)
            .sum()
}

/**
 * Check if the number is a truncatable prime (we can remove digits from left or right and the number will stay prime)
 * @return true if and only if the number is a truncatable prime
 */
fun Long.isTruncatablePrime(): Boolean {
    // Right truncation
    var prime = this.toString()
    while (prime.isNotEmpty()) {
        if (!prime.toLong().isPrime()) return false
        prime = prime.substring(0, prime.length - 1)
    }

    // Left truncation
    prime = this.toString()
    while (prime.length >= 1) {
        if (!prime.toLong().isPrime()) return false
        prime = prime.substring(1, prime.length)
    }

    return true
}

/**
 * Problem 38
 *
 * Take the number 192 and multiply it by each of 1, 2, and 3:
 * 192 × 1 = 192
 * 192 × 2 = 384
 * 192 × 3 = 576
 * By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)
 * The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645,
 * which is the concatenated product of 9 and (1,2,3,4,5).
 * What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?
 */
fun problem38(): Int {
    var largest = 0
    for (i in 98765 downTo 1) {
        var n = 1
        var concat = ""
        while (concat.length < 9) {
            concat += (i * n).toString()
            n++
        }
        if (concat.length == 9 && concat.toInt() > largest && concat.isPandigital()) largest = concat.toInt()
    }
    return largest
}

/**
 * Problem 39
 *
 * If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.
 * {20,48,52}, {24,45,51}, {30,40,50}
 * For which value of p ≤ 1000, is the number of solutions maximised?
 */
fun problem39(): Int {
    var maxSolutionsP = 0
    var maxSolutions = 0
    for (p in 1..1000) {
        var solutions = 0
        for (c in 1..p - 2) {
            for (b in 1..p - 1 - c) {
                val a = p - c - b

                if (a < b && a * a + b * b == c * c) solutions++
            }
        }
        if (solutions > maxSolutions) {
            maxSolutions = solutions
            maxSolutionsP = p
        }
    }
    return maxSolutionsP
}

/**
 * Problem 40
 *
 * An irrational decimal fraction is created by concatenating the positive integers:
 * 0.123456789101112131415161718192021...
 * It can be seen that the 12th digit of the fractional part is 1.
 * If dn represents the nth digit of the fractional part, find the value of the following expression.
 * d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000
 */
fun problem40(): Int {
    val sequence = getNaturalNumberDigitSequence()
    var product = 1
    for (i in 0..6) {
        product *= sequence.elementAt(10.pow(i).toInt() - 1)
    }
    return product
}

/**
 * Generator that generates a sequence of digits which make up the natural numbers together
 * @return sequence of digits of increasing natural numbers
 */
fun getNaturalNumberDigitSequence(): Sequence<Int> {
    return sequence {
        var n = 1
        while (true) {
            for (digit in n.toString()) {
                yield(digit.intVal())
            }
            n += 1
        }
    }
}

/**
 * Problem 41
 *
 * We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once.
 * For example, 2143 is a 4-digit pandigital and is also prime.
 * What is the largest n-digit pandigital prime that exists?
 */
fun problem41(): Long {
    for (length in 9 downTo 1) {
        val prime = (1..length).joinToString("").permutations().lastOrNull { it.toLong().isPrime() }
        if (prime != null) return prime.toLong()
    }
    return -1
}

/**
 * Generator that generates a sequence of all the prime numbers
 * @return sequence of increasing prime numbers
 */
fun getPrimes(): Sequence<Long> {
    return sequence {
        var n = 2L
        while (true) {
            if (n.isPrime()) yield(n)
            n++
        }
    }
}

/**
 * Get all the permutations of a string
 * @return list of permutations
 */
fun String.permutations(): ArrayList<String> {
    val permutations = ArrayList<String>()
    fun permutations(prefix: String, str: String) {
        val n = str.length
        if (n == 0)
            permutations.add(prefix)
        else {
            for (i in 0 until n)
                permutations(prefix + str[i], str.substring(0, i) + str.substring(i + 1, n))
        }
    }
    permutations("", this)
    return permutations
}

/**
 * Problem 42
 *
 * The nth term of the sequence of triangle numbers is given by, t(n) = (1/2)n(n+1); so the first ten triangle numbers are:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * By converting each letter in a word to a number corresponding to its alphabetical position and adding these values
 * we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t(10).
 * If the word value is a triangle number then we shall call the word a triangle word.
 * Using words.txt (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words,
 * how many are triangle words?
 */
fun problem42(): Int {
    val names = Data.problem42()
    val offset = 'A'.toInt() - 1
    var triangleWords = 0
    for (name in names) {
        var score = 0L
        for (letter in name) {
            score += letter.toInt() - offset
        }
        if (score == getTriangleNumbers().takeWhile { it <= score }.last()) triangleWords++
    }
    return triangleWords
}

/**
 * Generator that generates triangle numbers (t(n) = (1/2)n(n+1))
 * @return sequence of triangle numbers
 */
fun getTriangleNumbers(): Sequence<Long> {
    return sequence {
        var n = 1L
        while (true) {
            yield(n * (n + 1) / 2)
            n++
        }
    }
}

/**
 * Problem 43
 *
 * The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order,
 * but it also has a rather interesting sub-string divisibility property.
 * Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:
 * d2d3d4=406 is divisible by 2
 * d3d4d5=063 is divisible by 3
 * d4d5d6=635 is divisible by 5
 * d5d6d7=357 is divisible by 7
 * d6d7d8=572 is divisible by 11
 * d7d8d9=728 is divisible by 13
 * d8d9d10=289 is divisible by 17
 * Find the sum of all 0 to 9 pandigital numbers with this property.
 */
fun problem43(): Long {
    return "0123456789".permutations().filter {
        it.substring(1, 4).toInt() % 2 == 0 &&
                it.substring(2, 5).toInt() % 3 == 0 &&
                it.substring(3, 6).toInt() % 5 == 0 &&
                it.substring(4, 7).toInt() % 7 == 0 &&
                it.substring(5, 8).toInt() % 11 == 0 &&
                it.substring(6, 9).toInt() % 13 == 0 &&
                it.substring(7, 10).toInt() % 17 == 0
    }.toLongList().sum()
}

/**
 * Problem 44
 *
 * Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
 * Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised;
 * what is the value of D?
 */
fun problem44(): Int {
    var result = 0
    var notFound: Boolean = true
    var i = 1

    while (notFound) {
        i++
        val n = i * (3 * i - 1) / 2

        for (j in i - 1 downTo 1) {
            val m = j * (3 * j - 1) / 2
            if ((n - m).isPentagonal() && (n + m).isPentagonal()) {
                result = n - m
                notFound = false
                break
            }
        }
    }
    return result
}

/**
 * Check if a number is pentagonal
 * @return true if and only if the number is pentagonal
 */
fun Int.isPentagonal(): Boolean {
    val result = (Math.sqrt(24 * this.toDouble() + 1) + 1) / 6
    return result == result.toInt().toDouble()
}

/**
 * Problem 45
 *
 * Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
 * Triangle	 	    Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 * Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
 * Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
 * It can be verified that T285 = P165 = H143 = 40755.
 * Find the next triangle number that is also pentagonal and hexagonal.
 */
fun problem45(): Long {
    return getTriangleNumbers().first { it > 40755 && it.toInt().isHexagonal() && it.toInt().isPentagonal() }
}

/**
 * Check if a number is hexagonal
 * @return true if and only if the number is hexagonal
 */
fun Int.isHexagonal(): Boolean {
    val result = 0.25 + Math.sqrt(0.5 * this + 0.0625)
    return result == result.toInt().toDouble()
}

/**
 * Problem 46
 *
 * It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.
 * 9  = 7  + 2×1^2
 * 15 = 7  + 2×2^2
 * 21 = 3  + 2×3^2
 * 25 = 7  + 2×3^2
 * 27 = 19 + 2×2^2
 * 33 = 31 + 2×1^2
 * It turns out that the conjecture was false.
 * What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
 */
fun problem46(): Long {
    return getCompositeNumbers().first { !it.hasSumOfPrimeAndTwiceSquare() }
}

/**
 * Generator that generates composite numbers
 * @return sequence of increasing composite numbers
 */
fun getCompositeNumbers(): Sequence<Long> {
    return sequence {
        var n = 9L
        while (true) {
            if (n.isCompositeNumber()) yield(n)
            n += 2
        }
    }
}

/**
 * Check if a number is a composite number
 * @return true if and only if the number is a composite number
 */
fun Long.isCompositeNumber(): Boolean {
    for (i in 3..(this / 2) step 2) {
        if (this % i == 0L) return true
    }
    return false
}

/**
 * Check if a number can be written as a prime plus twice a square
 *
 */
fun Long.hasSumOfPrimeAndTwiceSquare(): Boolean {
    getPrimes().takeWhile { it < this }.forEach {
        val num = Math.sqrt(((this - it) / 2).toDouble())
        if (num.toInt().toDouble() == num) return true
    }
    return false
}

/**
 * Problem 47
 *
 * The first two consecutive numbers to have two distinct prime factors are:
 * 14 = 2 × 7
 * 15 = 3 × 5
 * The first three consecutive numbers to have three distinct prime factors are:
 * 644 = 2^2 × 7 × 23
 * 645 = 3 × 5 × 43
 * 646 = 2 × 17 × 19.
 * Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?
 */
fun problem47(): Long {
    var n = 210L
    var consecutiveNumbers = 0
    while (true) {
        if (n.numberOfPrimeFactors() == 4L) {
            if (consecutiveNumbers == 3) return n - 3
            consecutiveNumbers++
        } else {
            consecutiveNumbers = 0
        }
        n++
    }
}

/**
 * Calculate the number of prime factors a number has
 * @return number of prime factors
 */
fun Long.numberOfPrimeFactors(): Long {
    var numberOfFactors = 0L
    var primeFactor: Boolean
    var remain = this

    getPrimes().takeWhile { it <= this }.forEach {
        if (it * it > this) {
            return ++numberOfFactors
        }

        primeFactor = false
        while (remain % it == 0L) {
            primeFactor = true
            remain /= it
        }
        if (primeFactor) {
            numberOfFactors++
        }

        if (remain == 1L) {
            return numberOfFactors
        }
    }
    return numberOfFactors
}

/**
 * Problem 48
 *
 * The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
 * Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
 */
fun problem48(): String {
    var sum = BigInteger.ZERO
    for (i in 1..1000) {
        sum += BigInteger.valueOf(i.toLong()).pow(i)
    }
    return sum.toString().substring(sum.toString().length - 10, sum.toString().length)
}

/**
 * Problem 49
 *
 * The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways:
 * (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.
 * There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property,
 * but there is one other 4-digit increasing sequence.
 * What 12-digit number do you form by concatenating the three terms in this sequence?
 */
fun problem49(): String {
    val firstTerm = (1488..(9999 - 3330)).firstOrNull {
        it.toString().isPermutationOf((it + 3330).toString()) && it.toString().isPermutationOf((it + 6660).toString()) &&
                it.toLong().isPrime() && (it + 3330).toLong().isPrime() && (it + 6660).toLong().isPrime()
    } ?: return "-1"
    return "$firstTerm${firstTerm + 3330}${firstTerm + 6660}"
}

/**
 * Check if one string is a permutation of another string (has the same characters)
 * @return true if and only if the two strings are permutations of each other
 */
fun String.isPermutationOf(other: String): Boolean {
    return this.toSortedSet() == other.toSortedSet()
}

/**
 * Problem 50
 *
 * The prime 41, can be written as the sum of six consecutive primes:
 * 41 = 2 + 3 + 5 + 7 + 11 + 13
 * This is the longest sum of consecutive primes that adds to a prime below one-hundred.
 * The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.
 * Which prime, below one-million, can be written as the sum of the most consecutive primes?
 */
fun problem50(): Long {
    val primes = getPrimes().takeWhile { it < 1000000 }.toList()
    var maxConsecutivePrimes = 0
    var maxPrime = 0L
    for (i in 1 until primes.size) {
        var sum = 0L
        for (index in i until primes.size) {
            sum += primes[index]
            if (sum >= 1000000) break
            if (index - i > maxConsecutivePrimes && sum.isPrime()) {
                maxConsecutivePrimes = index - i
                maxPrime = sum
            }
        }
    }
    return maxPrime
}

/**
 * Problem 51
 *
 * By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values:
 * 13, 23, 43, 53, 73, and 83, are all prime.
 * By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among
 * the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003,
 * being the first member of this family, is the smallest prime with this property.
 * Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit,
 * is part of an eight prime value family.
 */
fun problem51(): Int {
    return -1
}

/**
 * Problem 52
 *
 * It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.
 * Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.
 */
fun problem52(): Long {
    var n = 2L
    while (true) {
        val string = n.toString()
        for (i in 2..6) {
            if (!(n * i).toString().isPermutationOf(string)) break
            else if (i == 6) return n
        }
        n++
    }
}

/**
 * Problem 53
 *
 * There are exactly ten ways of selecting three from five, 12345:
 * 123, 124, 125, 134, 135, 145, 234, 235, 245, and 345
 * In combinatorics, we use the notation, 5C3 = 10.
 * In general,
 * nCr = n!/r!(n−r)! ,where r ≤ n, n! = n×(n−1)×...×3×2×1, and 0! = 1.
 * It is not until n = 23, that a value exceeds one-million: 23C10 = 1144066.
 * How many, not necessarily distinct, values of  nCr, for 1 ≤ n ≤ 100, are greater than one-million?
 */
fun problem53(): Int {
    var count = 0
    val min = BigInteger.valueOf(1000000L)
    for (n in 1..100) {
        (1 until n).forEach {
            if (n nCr it > min) count++
        }
    }
    return count
}

/**
 * Problem 54
 *
 * Not finished
 */
fun problem54(): Int {
    return -1
}

/**
 * Problem 55
 *
 * If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.
 * Not all numbers produce palindromes so quickly. For example,
 * 349 + 943 = 1292,
 * 1292 + 2921 = 4213
 * 4213 + 3124 = 7337
 * That is, 349 took three iterations to arrive at a palindrome.
 * Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome.
 * A number that never forms a palindrome through the reverse and add process is called a Lychrel number.
 * Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is
 * Lychrel until proven otherwise.
 * In addition you are given that for every number below ten-thousand, it will either
 * (i) become a palindrome in less than fifty iterations, or,
 * (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome.
 * In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome:
 * 4668731596684224866951378664 (53 iterations, 28-digits).
 * Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.
 * How many Lychrel numbers are there below ten-thousand?
 */
fun problem55(): Int {
    var count = 0
    for (i in 0 until 10000) {
        if (i.isLychrel()) count++
    }
    return count
}

/**
 * Check if a number is a lynchrel number
 * @return true if and only if a number is a lynchrel number
 */
fun Int.isLychrel(): Boolean {
    var n = this.toBigInteger()
    for (iter in 0..50) {
        val sum = n + n.reversed()
        if (sum.toString().isPalindrome()) return false
        n = sum
    }
    return true
}

/**
 * Reverse a number
 * @return number with its digits reversed
 */
fun BigInteger.reversed(): BigInteger {
    return BigInteger(this.toString().reversed())
}

/**
 * Problem 56
 *
 * A googol (10^100) is a massive number: one followed by one-hundred zeros;
 * 100^100 is almost unimaginably large: one followed by two-hundred zeros.
 * Despite their size, the sum of the digits in each number is only 1.
 * Considering natural numbers of the form, a^b, where a, b < 100, what is the maximum digital sum?
 */
fun problem56(): Int {
    var max = 0
    for (a in 1 until 100) {
        for (b in 1 until 100) {
            val sum = a.pow(b).digitalSum()
            if (sum > max) {
                max = sum
            }
        }
    }
    return max
}

/**
 * Calculate the sum of all the digits of a number
 * @return sum of all the digits
 */
fun BigInteger.digitalSum(): Int {
    var digitSum = 0
    this.toString().forEach {
        digitSum += it - '0'
    }
    return digitSum
}

/**
 * Problem 57
 *
 * Not finished
 */
fun problem57(): Int {
    return -1
}

/**
 * Problem 58
 *
 * Not finished
 */
fun problem58(): Int {
    return -1
}

/**
 * Problem 59
 *
 * Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange).
 * For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.
 * A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key.
 * The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example,
 * 65 XOR 42 = 107, then 107 XOR 42 = 65.
 * For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes.
 * The user would keep the encrypted message and the encryption key in different locations, and without both "halves",
 * it is impossible to decrypt the message.
 * Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key.
 * If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message.
 * The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.
 * Your task has been made easy, as the encryption key consists of three lower case characters.
 * Using cipher.txt (right click and 'Save Link/Target As...'), a file containing the encrypted ASCII codes,
 * and the knowledge that the plain text must contain common English words,
 * decrypt the message and find the sum of the ASCII values in the original text.
 */
fun problem59(): Int {
    val encrypted = Data.problem59()
    val size = encrypted.size
    for (a in 97..122) { // Ascii values for 'a'..'z'
        for (b in 97..122) {
            key@ for (c in 97..122) {
                val key = arrayOf(a, b, c)
                val decrypted = ArrayList<Int>()
                for (i in 0 until size) {
                    val char = encrypted[i].xor(key[i % 3])
                    if (char < 32 || char > 126) continue@key // Only characters and punctuation marks allowed
                    decrypted.add(encrypted[i].xor(key[i % 3]))
                }
                val decryptedString = String(decrypted.map { it.toByte() }.toByteArray())
                if (decryptedString.contains("the") && !decryptedString.contains("#") && !decryptedString.contains("$"))
                    return decrypted.sum()
            }
        }
    }
    return 0
}
